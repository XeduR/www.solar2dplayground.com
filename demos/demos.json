[
    {
        "title": "Crate",
        "code": "-- Sample code by Eetu Rantanen.\n\n-- Change the background to blue.\ndisplay.setDefault( \"background\", 0, 0.3, 0.8 )\n\n-- Require and start the physics engine.\nlocal physics = require(\"physics\")\nphysics.start()\nphysics.setGravity( 0, 98.1 ) -- Setting a very high gravity.\n\n-- Create a sword altar, the ground and a crate, and give them all physics bodies.\nlocal swordShape = { -2, -62, 9, -62, 49, 10, 49, 95, -40, 95, -40, 10 }\nlocal sword = display.newImage( \"img/alter.png\", 510, 490 )\nphysics.addBody( sword, \"dynamic\", { density=1, friction=0.9, bounce=0, shape=swordShape } )\n\nlocal block = display.newImage( \"img/pushBlock3.png\", 480, 100 )\nphysics.addBody( block, \"dynamic\", { density=1, friction=2, bounce=0 } )\nblock.angularDamping = 3\n-- block:setFillColor( 1, 0, 0 ) -- Uncomment this line to apply red tint to the block.\n\nfor i = 1, 4 do\n\tlocal ground = display.newImage( \"img/platformBase2.png\", i*250-160, 630 )\n\tphysics.addBody( ground, \"static\", { density=1, friction=0.9, bounce=0 } )\nend\n\nlocal text = display.newText( \"Drag the block with your mouse\", 640, 40, native.systemFontBold, 40 )\n\nlocal function dragObject( event )\n\tlocal body = event.target\n\tlocal phase = event.phase\n\tlocal stage = display.getCurrentStage()\n\n\tif phase == \"began\" then\n\t\tstage:setFocus( body )\n\t\tbody.isFocus = true\n\t\tbody.tempJoint = physics.newJoint( \"touch\", body, event.x, event.y )\n\n\telseif body.isFocus then\n\t\tif phase == \"moved\" then\n\t\t\tbody.tempJoint:setTarget( event.x, event.y )\n\n\t\telse\n\t\t\tstage:setFocus( nil )\n\t\t\tbody.isFocus = false\t\n\t\t\tbody.tempJoint:removeSelf()\n\n\t\tend\n\tend\n\n\treturn true\nend\nblock:addEventListener( \"touch\", dragObject )\n-- sword:addEventListener( \"touch\", dragObject ) -- Uncomment to make the sword draggable too.\n"
    },
    
    {
        "title": "Memory",
        "code": "-- Sample code by Eetu Rantanen.\n\n-- Change the background to burgundy.\ndisplay.setDefault( \"background\", 0.55, 0, 0.2 )\nlocal images = { \"img/spaceWrench.png\", \"img/spaceGun.png\", \"img/spaceGrenade.png\", \"img/spaceKey.png\", \"img/spaceExtinguisher.png\", \"img/spaceCup.png\" }\nlocal sfxFlip = audio.loadSound( \"sfx/flip1.ogg\" )\n\n-- Save time by creating one function to handle flipping all tokens.\nlocal function flip( target, time, listener )\n\tlocal offset = 64\n\tif target.path.x1 == 64 then offset = 0 end\n\ttransition.to( target.path, { time=time, x1=offset, x2=offset, x3=-offset, x4=-offset, onComplete=listener } )\nend\n\nlocal canTouch, previous = true\nlocal function checkResult( target )\n\tif not previous then\n\t\tprevious = target\n\t\tcanTouch = true\n\telse\n\t\tif target.id == previous.id then\n\t\t\t-- In this sample code, nothing actually gets removed, they are just hidden.\n\t\t\ttransition.to( target.front, { time=300, alpha=0 } )\n\t\t\ttransition.to( previous.front, { time=300, alpha=0, onComplete=function()\n\t\t\t\tprevious = nil\n\t\t\t\tcanTouch = true\n\t\t\tend } )\n\t\telse\n\t\t\ttimer.performWithDelay( 300, function() -- Wait before flipping the tokens.\n\t\t\t\t -- First hide the front, then reveal the back.\n\t\t\t\tflip( target.front, 100, function() flip( target, 100 ) end )\n\t\t\t\tflip( previous.front, 100, function() flip( previous, 100, function()\n\t\t\t\t\t\tprevious = nil\n\t\t\t\t\t\tcanTouch = true\n\t\t\t\t\tend )\n\t\t\t\tend )\n\t\t\tend )\n\t\tend\n\tend\nend\n\nlocal function touchListener( event )\n\tif canTouch and event.phase == \"began\" then\n\t\taudio.play( sfxFlip )\t\n\t\tcanTouch = false -- Prevent further touches until the transitions have finished.\n\t\tflip( event.target, 100, function() -- First hide the back, then reveal the front.\n\t\t\tflip( event.target.front, 100, function() checkResult( event.target ) end )\n\t\tend )\n\tend\nend\n\nlocal token, n = {}, 1\nfor i = 1, 12 do\n\ttoken[i] = display.newImage( images[n], 270+math.floor((i-1)/3)*140, 180+math.fmod((i-1),3)*140 )\n\tflip( token[#token], 0 )\n\ttoken[i].back = display.newImage( \"img/spaceMonster.png\", token[i].x, token[i].y )\n\ttoken[i].back.front = token[i] -- Add a refence to the front side of the token.\n\ttoken[i].back.id = n -- This id will be used to identify correct pairs.\n\ttoken[i].back:addEventListener( \"touch\", touchListener )\n\tn = n+1\n\tif n > 6 then -- We've got six images, so create another pair of them.\n\t\tn = 1\n\tend\nend\n\nfor i = 1, 12 do -- Shuffle the tokens around.\n\tlocal target = math.random(12)\n\tlocal xNew, yNew = token[target].x, token[target].y\n\ttoken[target].x, token[target].y, token[target].back.x, token[target].back.y = token[i].x, token[i].y, token[i].x, token[i].y\n\ttoken[i].x, token[i].y, token[i].back.x, token[i].back.y = xNew, yNew, xNew, yNew\nend\n"
    },
    
    {
        "title": "Knight",
        "code": "-- Sample code by Eetu Rantanen.\n\n-- Change the background to grey.\ndisplay.setDefault( \"background\", 0.2 )\nlocal instructions = display.newText( \"Use wasd or arrows to move. Press space to jump.\", 480, 120, \"fonts/OpenSansRegular.ttf\", 32 )\n\n-- Image fills that will be used for enterFrame animations for the knight.\nlocal frameMove1 = { type = \"image\", filename = \"img/walk1.png\" }\nlocal frameMove2 = { type = \"image\", filename = \"img/walk2.png\" }\nlocal frameIdle = { type = \"image\", filename = \"img/stand.png\" }\nlocal frameJump = { type = \"image\", filename = \"img/jump.png\" }\n\n-- Declaring multiple similar variables on the same line to reduce repetition.\nlocal movementDirection, state1, inAir = \"right\", true, false\n-- The knight's start/previous x location, as well as movement speed, jump height and jump duration.\nlocal prevX, moveSpeed, jumpHeight, jumpDuration = 480, 8, 80, 200\nlocal knightGroup = display.newGroup() -- By adding the knight and his shadow to a group, we can handle both at the same time.\n\nlocal shadow = display.newCircle( knightGroup, prevX, 396, 46 )\nshadow:setFillColor(0)\nshadow.alpha = 0.5\nshadow.yScale = 0.5 -- Adjust the yScale to give the shadow the proper perspective.\n\nlocal knight = display.newRect( knightGroup, prevX, 320, 156, 156 )\nknight.fill = frameIdle\n\nlocal action = {}\nlocal framesBetweenChange, currentFrame = 4, 1\nlocal function moveCharacter()\n\tlocal keyDown = false\n\t-- See if one of the selected action buttons is down and move the knight.\n\tif action[\"a\"] or action[\"left\"] then\n\t\tknightGroup:translate( -moveSpeed, 0 )\n\t\tkeyDown = true\n\tend\n\tif action[\"d\"] or action[\"right\"] then\n\t\tknightGroup:translate( moveSpeed, 0 )\n\t\tkeyDown = true\n\tend\n\tif action[\"w\"] or action[\"up\"] then\n\t\tknightGroup:translate( 0, -moveSpeed )\n\t\tkeyDown = true\n\tend\n\tif action[\"s\"] or action[\"down\"] then\n\t\tknightGroup:translate( 0, moveSpeed )\n\t\tkeyDown = true\n\tend\n\tif keyDown then -- Only animate if one of the keys is pressed.\n\t\tif movementDirection == \"right\" and knightGroup.x < prevX then\n\t\t\tmovementDirection = \"left\"\n\t\t\tknight.xScale = -1\n\t\telseif movementDirection == \"left\" and knightGroup.x > prevX then\n\t\t\tmovementDirection = \"right\"\n\t\t\tknight.xScale = 1\n\t\tend\n\t\tcurrentFrame = currentFrame+1\n\t\tif currentFrame > framesBetweenChange then\n\t\t\tstate1 = not state1 -- Changes true to false and vice versa.\n\t\t\tcurrentFrame = 1\n\t\tend\n\t\tif not inAir then\n\t\t\tif state1 then -- Change the shadow scale and knight.y to make the knight \"wobble\".\n\t\t\t\tknight.fill = frameMove2\n\t\t\t\tknight.y = shadow.y-76\n\t\t\t\tshadow.xScale, shadow.yScale = 1, 0.5\n\t\t\telse\n\t\t\t\tknight.fill = frameMove1\n\t\t\t\tknight.y = shadow.y-78\n\t\t\t\tshadow.xScale, shadow.yScale = 1.05, 0.45\n\t\t\tend\n\t\tend\n\t\tprevX = knightGroup.x\n\telseif not inAir then -- If the knight isn't moving or in the air, then toggle idle frame.\n\t\tknight.fill = frameIdle\n\tend\nend\n\nlocal function onKeyEvent( event )\n\tif event.phase == \"down\" then\n\t\taction[event.keyName] = true\n\t\tif event.keyName == \"space\" and not inAir then\n\t\t\tinAir = true\n\t\t\tknight.fill = frameJump\n\t\t\t-- Use transitions to jump the knight up and down, as well as animate the shadow.\n\t\t\ttransition.to( knight, { time=jumpDuration*0.5, y=knight.y-jumpHeight, onComplete=function()\n\t\t\t\ttransition.to( knight, { time=jumpDuration*0.5, y=knight.y+jumpHeight, onComplete=function()\n\t\t\t\t\tinAir = false\n\t\t\t\t\tknight.fill = frameIdle\n\t\t\t\tend })\n\t\t\tend })\n\t\t\ttransition.to( shadow, { time=jumpDuration*0.5, alpha=0.3, xScale=0.8, yScale=0.3, onComplete=function()\n\t\t\t\ttransition.to( shadow, { time=jumpDuration*0.5, alpha=0.5, xScale=1, yScale=0.5 })\n\t\t\tend })\n\t\tend\n\telse\n\t\taction[event.keyName] = false\n\tend\nend\n\nRuntime:addEventListener( \"enterFrame\", moveCharacter )\nRuntime:addEventListener( \"key\", onKeyEvent )\n"
    },
    
    {
        "title": "Bomb Tap",
        "code": "-- Sample code by Eetu Rantanen.\n\ndisplay.setDefault( \"background\", 0.3 ) -- Change the background to grey.\nlocal physics = require(\"physics\")\nphysics.start()\nphysics.setGravity( 0, 50 )\nphysics.pause() -- Physics are paused until the game starts.\nlocal shiftTimer, started\nlocal sfxGameover = audio.loadSound( \"sfx/pepSound1.ogg\" )\n\nlocal platformTop = display.newImage( \"img/platformBase3.png\", display.contentCenterX, display.contentCenterY - 150 )\nphysics.addBody( platformTop, \"static\" )\nplatformTop.xScale, platformTop.yScale = -1, -1 -- Flip the top platform over its x and y-axes.\n\nlocal platformBottom = display.newImage( \"img/platformBase3.png\", display.contentCenterX, display.contentCenterY + 150 )\nphysics.addBody( platformBottom, \"static\" )\n\nlocal bomb = display.newImage( \"img/bombStroked.png\", display.contentCenterX, display.contentCenterY )\nphysics.addBody( bomb, { shape={ -20,-10, 28,-10, 28,40, -20,40 } } )\nbomb.isFixedRotation = true -- Prevent the bomb from spinning around its axis.\n\nlocal instructions = display.newText( \"Tap anywhere to Jump. Don't let the bomb get hit!\", display.contentCenterX, 40, \"fonts/OpenSansRegular.ttf\", 28 )\ninstructions:setFillColor( 1 )\n\nlocal function shift() -- Shift the platforms up or down at random.\n\tlocal yTo = math.random( -150, 150 )\n\ttransition.to( platformTop, { time=1000, y=display.contentCenterY-150+yTo } )\n\ttransition.to( platformBottom, { time=1000, y=display.contentCenterY+150+yTo } )\nend\n\nlocal function jump( event )\n\tif event.phase == \"began\" then\n\t\tif not started then -- Starts the game if it hasn't started yet.\n\t\t\tstarted = true\n\t\t\tphysics.start()\n\t\t\tshiftTimer = timer.performWithDelay( 750, shift, 0 )\n\t  \t\tdisplay.setDefault( \"background\", 0.3 ) -- Restore the background colour.\n\t\tend\n\t\tbomb:setLinearVelocity( 0, 0 ) -- Reset the bomb's current linear velocity.\n\t\tbomb:applyLinearImpulse( 0, -0.3 ) -- And give it an upwards impulse.\n\tend\nend\n\nlocal function collision( event ) -- If a collision begins, it means the game is over.\n\tif event.phase == \"began\" then\n\t\tdisplay.setDefault( \"background\", 0.6, 0, 0 ) -- Make the background red to emphasise gameover.\n\t\taudio.play( sfxGameover )\n\t\ttimer.cancel( shiftTimer )\n\t\ttransition.cancel()\n\t\tphysics.pause()\n\t\ttimer.performWithDelay( 100, function()\n\t\t\tplatformTop.y, platformBottom.y, bomb.y = display.contentCenterY-150, display.contentCenterY+150, display.contentCenterY\n\t\t\tstarted = false\n\t\tend )\n\tend\nend\n\nRuntime:addEventListener( \"touch\", jump )\nRuntime:addEventListener( \"collision\", collision )\n"
    },
    
    {
        "title": "Physics Typer",
        "code": "-- Sample code by Michael Wilson.\n\n-- Change the background to grey.\ndisplay.setDefault( \"background\", 0.1 )\n\nlocal x, y = display.contentCenterX, display.contentCenterY -- source of the letters\nlocal rnd = math.random\n\n-- Help text.\ndisplay.newText( {text = \"Start typing...\", x = x, y = y/4, fontSize = 32 } )\n\n-- Require and start the physics engine.\nlocal physics = require(\"physics\")\nphysics.start()\nphysics.setGravity( 0, 64 ) -- Set gravity.\n\nlocal ground = display.newRect(x,display.contentHeight, display.contentWidth * 2, 16)\nground.alpha = 0.25\nphysics.addBody(ground, \"static\")\n\n-- Text options.\nlocal options = { x = x, y = y, fontSize = 128, font = native.systemFontBold }\n\n-- Called when a key event has been received.\nlocal function key( event )\n\tif event.phase == \"up\" then\n\t\t-- Create the key you pressed.\n\t\toptions.text = event.keyName:len() == 1 and event.keyName or \"?\" -- One letter keys only.\n\t\tlocal letter = display.newText( options )\n\t\t-- Render the text to a display object.\n\t\tlocal object = display.capture(letter)\n\t\t-- Add a premade shader.\n\t\tobject.fill.effect = \"filter.colorChannelOffset\"\n\t\tobject.fill.effect.xTexels = 4\n\t\tobject.fill.effect.yTexels = 4\n\t\tobject:translate(x,y) -- Move from 0,0.\n\t\t-- Remove the letter.\n\t\tdisplay.remove(letter)\n\t\t-- Let's give it a quick physics body.\n\t\tphysics.addBody(object, { radius = 32, bounce = 0.5, friction = 0 } )\n\t\tobject.linearDamping = 1\n\t\tobject.angularDamping= 1\n\t\t-- Give it a push.\n\t\tobject:applyLinearImpulse(rnd()-rnd(),-rnd()-rnd(),rnd(),rnd())\n\t\tobject.angularVelocity = object.angularVelocity * 0.025 -- cap spin speed\n\tend\nend\n\n-- Add the key listener.\nRuntime:addEventListener( \"key\", key )\n"
    },
    
    {
        "title": "Flame",
        "code": "-- Sample code by Michael Wilson.\n\n-- Change the background to grey.\ndisplay.setDefault( \"background\", 0.1 )\n\nlocal x, y = display.contentCenterX, display.contentCenterY -- Source of flame.\nlocal rnd = math.random\n\n-- Run every frame.\nlocal function enterFrame()\n\tlocal flame = display.newCircle(x,y, math.random(32,64))\n\tflame:setFillColor(rnd() + 0.5, rnd() + 0.2, 0)\n\tflame.blendMode = \"add\"\n\tflame.alpha = 0.5\n\n\t-- Kill the particle when done.\n\tlocal function die()\n\t\tdisplay.remove(flame)\n\tend\n\n\t-- Start a transition.\n\ttransition.to(flame, {\n\t\tdelta = true, -- Move from current location.\n\t\ttime = 1000, -- In 1.0 seconds.\n\t\tx = rnd(-16,16), -- Wiggle.\n\t\ty = rnd(-384, -256), -- Go up.\n\t\txScale = -0.9, -- Shrink.\n\t\tyScale = -0.9,\n\t\tonComplete = die, -- And die.\n\t})\nend\n\n-- Called when a mouse event has been received.\nlocal function mouse( event )\n\tif event.type ~= \"scroll\" then -- Check that the user isn't scrolling.\n\t\tx, y = event.x or x, event.y or y -- Take a new x,y or keep the old x,y.\n\tend\nend\n\n-- Add the mouse and enterFrame events.\nRuntime:addEventListener( \"mouse\", mouse )\nRuntime:addEventListener( \"enterFrame\", enterFrame )\n-- Since mobile devices don't have a mouse, the \"mouse\" listener from above \n-- won't work with them, but we can add a \"touch\" listener for such devices.\nRuntime:addEventListener( \"touch\", mouse )\n"
    },
    
    {
        "title": "Prey Simulator",
        "code": "-- Sample code by Jonathan Sharp.\n\n-- Require and start the physics engine.\nlocal physics = require(\"physics\")\nphysics.start()\nphysics.setGravity( 0, 0 ) -- Zero gravity.\n\nlocal cx, cy = display.contentCenterX, display.contentCenterY -- Screen center coordinates.\nlocal predatorSize, preySize, dangerZone, time = 45, 24, 200, 400 -- Object and time variables.\nlocal angleBetween, distanceBetween, moveTo, getRandomTarget -- Forward references to movement functions.\n\nlocal background = display.newRect(\n\tdisplay.safeScreenOriginX,\n\tdisplay.safeScreenOriginY,\n\tdisplay.safeActualContentWidth,\n\tdisplay.safeActualContentHeight\n)\nbackground.x = cx ; background.y = cy\nbackground:setFillColor( 0, 0.68, 0.99, 0.5 )\n\n-- Help text.\nlocal text = display.newText( {text = \"Tap anywhere to spawn more prey!\", x = display.contentCenterX, y = display.contentCenterY/4, fontSize = 32 } )\nlocal textTrans = transition.to( text, { delay=5000, time=1200, alpha = 0, onComplete=\n\tfunction() \n\t\tdisplay.remove( text ) ; text = nil\n\tend} )\n\nlocal predator = display.newImageRect( \"img/shapeBall.png\", predatorSize, predatorSize )\npredator.x = cx ; predator.y = cy\npredator:setFillColor( 0.8, 0.4, 0.4)\nphysics.addBody( predator, \"dynamic\", {radius = predatorSize * 0.5})\npredator.linearDamping = 1\n\nfunction predator:move( )\n\t-- queryRegion returns a list of display objects within its bounds.\n\tlocal querytList = physics.queryRegion( 0, 0, display.safeActualContentWidth, display.safeActualContentHeight )\n\tlocal closestMeasure = 10000 -- Ridiculously large so every object will be closer.\n\tlocal targetFood = false -- If prey are available, targetFood will be set to a prey object.\n\tif querytList then\n\t\tfor i=1,#querytList do\n\t\t\tlocal object = querytList[i]\n\t\t\tif object ~= predator and object ~= background then -- Exclude the predator and the background.\n\t\t\t\tlocal prey = object\n\t\t\t\tprey:setFillColor( 0.2, 0.8, 0.4 )\n\t\t\t\tlocal foodDistance = distanceBetween( predator, prey)\n\t\t\t\tif foodDistance < closestMeasure then -- Find the closest prey by comparison.\n\t\t\t\t\tclosestMeasure = foodDistance\n\t\t\t\t\ttargetFood = prey -- targetFood represents the closest prey.\n\t\t\t\tend\n\t\t\t\tif foodDistance < dangerZone then -- If the predator is close, set the prey to runaway.\n\t\t\t\t\tprey.runAway = true\n\t\t\t\telse\n\t\t\t\t\tprey.runAway = false\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\t\n\tif targetFood ~= false then -- targetFood equals the closest prey.\n\t\tmoveTo(predator, targetFood, 1.4)\n\t\ttargetFood:setFillColor(1,1,0.2)\n\telse -- If targetFood is false - no prey found - make a random movement.\n\t\tlocal randomTarget = getRandomTarget() \n\t\tmoveTo(predator, randomTarget)\n\tend\nend\npredator.timer = timer.performWithDelay( time, predator.move, -1 )\n\nfunction predator.collision( event )\n\tif event.phase == 'began' then\n\t\tif event.other.type == \"prey\" then event.other:die() end\n\tend\nend\n\nlocal function makeFood( event ) -- Generate food where background is touched.\n\tif event.phase == \"began\" then -- Triggered during \"began\" phase only.\n\t\tlocal prey = display.newImageRect( \"img/shapeBall.png\", preySize, preySize )\n\t\tprey.x = event.x ; prey.y = event.y\n\t\tprey:setFillColor( 0.2, 0.8, 0.4, 0.8 )\n\t\tphysics.addBody( prey, \"dynamic\", {radius = preySize*0.5})\n\t\tprey.linearDamping = 1\n\t\tprey.runAway = false -- When prey.runAway equals true, the prey will run from the predator.\n\t\tprey.type = \"prey\"\n\n\t\tfunction prey:die(  )\n\t\t\tlocal deathCircle = display.newImageRect( \"img/shapeBall.png\", preySize, preySize )\n\t\t\tdeathCircle.x = self.x ; deathCircle.y = self.y\n\t\t\tdeathCircle:setFillColor(1,1,0.2)\n\t\t\tdeathCircle.blendMode = \"add\"\n\t\t\ttimer.cancel( self.timer )\n\t\t\tdisplay.remove( self ) ; self = nil\n\n\t\t\tlocal trans1 = transition.to( deathCircle, { time=200, alpha = 0, xScale=3, yScale=3, onComplete=\n\t\t\t\tfunction() \n\t\t\t\t\tdisplay.remove( deathCircle ) ; deathCircle = nil\n\t\t\t\tend} )\n\t\tend\n\n\t\tlocal function move( )\n\t\t\tif prey.runAway == true and distanceBetween(prey, predator) < dangerZone * 2 then\n\t\t\t\tmoveTo(prey, predator, -1.2)\n\t\t\telse\n\t\t\t\tlocal randomTarget = getRandomTarget()\n\t\t\t\tmoveTo(prey, randomTarget)\n\t\t\tend\t\n\t\tend\n\n\t\tprey.timer = timer.performWithDelay( time, move, -1 )\n\tend\nend\n\n-- Add touch listener to the background.\nbackground:addEventListener( \"touch\", makeFood )\n-- Add event listener to the predator collisions.\npredator:addEventListener( \"collision\", predator.collision )\n\n-----------------------------------------------------------------------\n--- Functions for movement ---\n-----------------------------------------------------------------------\n-- Find angle.\nfunction angleBetween( object, target )\n\tlocal angle = math.atan2( target.y - object.y, target.x - object.x)\n\treturn angle -- Returns angle in radians.\nend\n\n-- Find distance.\nfunction distanceBetween( object, target)\n\tlocal xfactor = object.x - target.x\n\tlocal yfactor = object.y - target.y\n\tlocal distance = math.sqrt( xfactor * xfactor + yfactor * yfactor )\n\treturn distance\nend\n\n-- Physics movement - object moves toward target with an optional force factor (force can be negative).\nfunction moveTo( object, target, force) \n\tlocal angle = angleBetween(object, target)\n\tlocal force = force or 1  -- Use -1 to move away from target.\n\tlocal xForce = math.cos(angle) * force * object.mass\n\tlocal yforce = math.sin(angle) * force * object.mass\n\n\tobject:applyLinearImpulse( xForce, yforce, object.x, object.y )\nend\n\n-- Generate a random target to move toward using moveTo().\nfunction getRandomTarget(  )\n\tlocal randomTarget = {\n\t\tx = math.random(display.safeActualContentWidth), \n\t\ty = math.random(display.safeActualContentHeight)\n\t}\n\treturn randomTarget\nend\n"
    },
    
    {
        "title": "Prey Joystick",
        "code": "-- Sample code by Jonathan Sharp.\n\n-- Require and start the physics engine.\nlocal physics = require(\"physics\")\nphysics.start()\nphysics.setGravity( 0, 0 ) -- Zero gravity.\n\nlocal cx, cy = display.contentCenterX, display.contentCenterY -- Screen center coordinates.\nlocal predatorSize, preySize, joystickSize, dangerZone, time = 45, 24, 87, 150, 200 -- Object and time variables.\nlocal angleBetween, distanceBetween, moveTo, getRandomTarget -- Forward references to movement functions.\nlocal joystick, prey -- Forward references to objects.\n\nlocal background = display.newRect(\n\tdisplay.safeScreenOriginX,\n\tdisplay.safeScreenOriginY,\n\tdisplay.safeActualContentWidth,\n\tdisplay.safeActualContentHeight\n)\nbackground.x = cx ; background.y = cy\nbackground:setFillColor( 0, 0.68, 0.99, 0.5 )\n\n-- Help text.\nlocal text = display.newText( {text = \"← Use the joystick to survive!\", x = display.contentCenterX, y = display.contentCenterY/4, fontSize = 32 } )\nlocal textTrans = transition.to( text, { delay=5000, time=1200, alpha = 0, onComplete=\n\tfunction() \n\t\tdisplay.remove( text ) ; text = nil\n\tend} )\n\nlocal preySpeed = 250\nlocal predatorCount = 10\nlocal predatorStartDistance = 350\n\n-----------------------------------------------------------------------\n--- prey ---\n-----------------------------------------------------------------------\nprey = display.newCircle( cx, cy, preySize*0.5 )\nprey.x = cx ; prey.y = cy\nprey:setFillColor( 0.2, 0.8, 0.4, 0.8 )\nphysics.addBody( prey, \"dynamic\", {radius = preySize*0.5})\nprey.linearDamping = 3\nprey.type = \"prey\"\n\nfunction prey:die(  )\n\tlocal deathCircle = display.newCircle( prey.x, prey.y, preySize*0.5 )\n\tdeathCircle.x = self.x ; deathCircle.y = self.y\n\tdeathCircle:setFillColor(1,1,0.2)\n\tdeathCircle.blendMode = \"add\"\n\tRuntime:removeEventListener( \"enterFrame\", prey.move )\n\tprey.alpha = 0\n\ttimer.performWithDelay( 50, function() prey.isBodyActive = false end )\n\n\tlocal trans1 = transition.to( deathCircle, { time=200, alpha = 0, xScale=3, yScale=3, onComplete=\n\t\tfunction() \n\t\t\tdisplay.remove( deathCircle ) ; deathCircle = nil\n\t\t\tprey.x = math.random( display.safeActualContentWidth )\n\t\t\tprey.y = math.random( display.safeActualContentHeight )\n\t\t\tprey.isBodyActive = true\n\t\t\tprey.alpha = 1\n\t\t\tRuntime:addEventListener( \"enterFrame\", prey.move )\n\t\tend} )\nend\n\nfunction prey.move( )\n\tif prey.x < 0 or prey.x > display.safeActualContentWidth or prey.y < 0 or prey.y > display.safeActualContentHeight then\n\t\tprey:die() -- Kill prey if it leaves the screen.\n\telseif joystick.isActive == true then\n\t\tlocal speed = preySpeed\n\t\tlocal xVelocity = math.cos(joystick.angle) * speed\n\t\tlocal yVelocity = math.sin(joystick.angle) * speed\n\t\tprey:setLinearVelocity( xVelocity, yVelocity )\n\tend\nend\nRuntime:addEventListener( \"enterFrame\", prey.move )\n\n-----------------------------------------------------------------------\n--- joystick ---\n-----------------------------------------------------------------------\njoystick = display.newCircle( cx, cy, joystickSize*0.5 )\njoystick.alpha = 0.1\njoystick.x = display.safeScreenOriginX + joystickSize\njoystick.y = display.safeScreenOriginY + display.safeActualContentHeight - joystickSize\njoystick.isActive = false\njoystick.isAvailable = true\n-- Update the help text location.\ntext.x = joystick.x + text.width*0.5 ; text.y = joystick.y\n\njoystick.bulb = display.newCircle( cx, cy, joystickSize*0.5 * 0.5 )\njoystick.bulb.alpha = 0.3\njoystick.bulb.x = joystick.x ; joystick.bulb.y = joystick.y\njoystick.bulb.isFocus = false\n\nlocal function control( event ) -- Generate food where background is touched.\n\tjoystick.angle = angleBetween(joystick, event)\n\tlocal t = event.target -- joystick.bulb\n\n\tif event.phase == \"began\" and joystick.isActive == false then -- If joystick is not active, make it active and make it the focus.\n\t\tjoystick.isActive = true\n\t\tdisplay.getCurrentStage():setFocus( t )\n\t\tt.isFocus = true\t\n\n\telseif t.isFocus == true then -- Once the joystick (joystick.bulb) has screen focus - move the bulb - which registers a new angle.\n\t\tif event.phase == \"moved\" and distanceBetween(joystick, joystick.bulb) < joystickSize * 2 then\n\t\t\tjoystick.isActive = true\n\t\t\tjoystick.bulb.x = event.x ; joystick.bulb.y = event.y\n\t\telse -- Event ended or joystick bulb is to far away from the joystick circle.\n\t\t\tjoystick.isActive = false\n\t\t\tjoystick.isAvailable = false\n\t\t\ttransition.to( joystick.bulb, { time=300, x = joystick.x, y = joystick.y, transition = easing.outBounce, onComplete=\n\t\t\t\tfunction() \n\t\t\t\t\tjoystick.isAvailable = true\n\t\t\t\tend} )\n\t\t\tdisplay.getCurrentStage():setFocus( nil )\n\t\t\tt.isFocus = false \n\t\t\tjoystick.isActive = false\n\t\tend\n\tend\n\treturn true -- Stops the touch from propogating to underlying objects.\nend\njoystick.bulb:addEventListener( \"touch\", control )\n\n-----------------------------------------------------------------------\n--- predator ---\n-----------------------------------------------------------------------\nlocal function makePredator( x,y )\n\tlocal predator = display.newCircle( cx, cy, predatorSize*0.5 )\n\tpredator.x = x ; predator.y = y\n\tpredator:setFillColor( 0.8, 0.4, 0.4)\n\tphysics.addBody( predator, \"dynamic\", {radius = predatorSize * 0.5})\n\tpredator.linearDamping = 1\n\n\tfunction predator.collision( event )\n\t\tif event.phase == 'began' then\n\t\t\tif event.other.type == \"prey\" then event.other:die() end\n\t\tend\n\tend\n\n\tfunction predator.move( ) -- Aggressive when near prey.\n\t\tif distanceBetween(predator, prey) < dangerZone then\n\t\t\tmoveTo(predator, prey,5)\n\t\telse\n\t\t\tmoveTo(predator, getRandomTarget())\n\t\tend\n\tend\n\n\tlocal randomTime = math.random( 300 ) -- For variation.\n\tpredator.timer = timer.performWithDelay( time + randomTime, predator.move, -1 )\n\tpredator:addEventListener( \"collision\", predator.collision )\nend\n\nfor i=1,predatorCount do -- Generate predators.\n\tlocal angle = math.random( math.pi * 2 *100)/100 -- Random placement around unit circle (in radians).\n\tmakePredator(cx + math.cos(angle) * predatorStartDistance, cy + math.sin(angle) * predatorStartDistance)\nend\n\n-----------------------------------------------------------------------\n--- functions for movement ---\n-----------------------------------------------------------------------\nfunction angleBetween( object, target )\n\tlocal angle = math.atan2( target.y - object.y, target.x - object.x)\n\treturn angle -- Returns angle in radians.\nend\n\nfunction distanceBetween( object, target)\n\tlocal xfactor = object.x - target.x\n\tlocal yfactor = object.y - target.y\n\tlocal distance = math.sqrt( xfactor * xfactor + yfactor * yfactor )\n\treturn distance\nend\n\n-- Physics movement - object moves toward target with an optional force factor (force can be negative).\nfunction moveTo( object, target, force) \n\n\tlocal angle = angleBetween(object, target)\n\tlocal force = force or 1  -- Use -1 to move away from target.\n\tlocal xForce = math.cos(angle) * force * object.mass\n\tlocal yforce = math.sin(angle) * force * object.mass\n\n\tobject:applyLinearImpulse( xForce, yforce, object.x, object.y )\nend\n\n-- Generate a random target to move toward using moveTo().\nfunction getRandomTarget(  )\n\tlocal randomTarget = {\n\t\tx = math.random(display.safeActualContentWidth), \n\t\ty = math.random(display.safeActualContentHeight)\n\t}\n\treturn randomTarget\nend\n"
    },
    
    {
        "title": "Knight Jump",
        "code": "-- Sample project by Ed Maurina (aka The Roaming Gamer).\n-- [Code adapted for Playground by Eetu Rantanen]\n\ndisplay.setDefault( \"background\", 0.4, 0.85, 1 )\n\n-- Localising frequently used global functions.\nlocal mRand = math.random\nlocal newImageRect = display.newImageRect\n\n-- Creating a shorthand for adding Runtime listeners.\nlocal listen = function( name, listener ) \n\tRuntime:addEventListener( name, listener ) \nend\n\nlocal physics = require(\"physics\")\nphysics.start()\nphysics.setGravity(0,60)\n\nlocal centerX  = display.contentCenterX\nlocal centerY  = display.contentCenterY\nlocal leftEdge  = display.screenOriginX\nlocal rightEdge = display.actualContentWidth - display.screenOriginX\n\nlocal gameIsRunning = true\nlocal horizSpeed\t= 500\nlocal jumpSpeed \t= 1100\nlocal offsetCamera  = 200\nlocal pickupCount   = 0\nlocal distance\t  = 0\n\nfunction display.newGroup2( insertInto )\n\tlocal group = display.newGroup()\n\tif( insertInto ) then insertInto:insert( group ) end\n\treturn group\nend\nlocal layers = display.newGroup2()\nlayers.world = display.newGroup2( layers )\nlayers.background = display.newGroup2( layers.world )\nlayers.content = display.newGroup2( layers.world )\nlayers.overlay = display.newGroup2( layers )\n\n-- Creating a rough physics shape for the player character to make the collisions more accurate.\nlocal player = newImageRect( layers.content, \"img/jump.png\", 117, 117 )\nplayer.x, player.y = centerX, centerY + 100\nplayer.startY = player.y\nplayer.moveLeft, player.moveRight = 0, 0\nphysics.addBody( player, \"dynamic\", { bounce = 0.1, shape = { -54, 20, -54, 0, 0, -56, 52, -56, 40, 42, 20, 56, -20, 56 } } )\nplayer.isFixedRotation = true\n\n-- Create a table to use for \"camera tracking\" purposes.\nlocal camera = { y=player.y+offsetCamera, lastY=player.y }\n\nlocal scoreBack = display.newRect( layers.overlay, centerX, 20, 140, 44 )\nscoreBack:setFillColor( 0.125, 0.125, 0.125 )\n\nlocal scoreLabel = display.newText( layers.overlay, 0, scoreBack.x, scoreBack.y, \"fnt/adventpro-regular.ttf\", 36 )\nscoreLabel:setFillColor(1,1,0)\n\nlocal function gameover()\n\tif gameIsRunning then\n\t\tgameIsRunning = false\n\t\tdisplay.setDefault( \"background\", 0.82, 0.17, 0.12 )\n\t\tplayer.moveLeft, player.moveRight = 0, 0\n\t\tplayer:removeEventListener(\"preCollision\")\n\t\tplayer:removeEventListener(\"collision\")\n\t\tRuntime:removeEventListener( \"enterFrame\", player )\n\t\t-- A delay of 1ms will run the following call the next frame.\n\t\ttimer.performWithDelay( 1,\n\t\t\tfunction()\n\t\t\t\tplayer.isSensor = true\n\t\t\t\tplayer:setFillColor( 1, 0, 0 )\n\t\t\t\tplayer.rotation = mRand(-45,45)\n\t\t\tend\n\t\t)\n\tend\nend\n\nfunction scoreLabel:update()\n\tself.text = pickupCount + distance\nend\n\nfunction player.preCollision( self, event )\n\tlocal contact \t\t= event.contact\n\tlocal other \t\t= event.other\n\tif( other.isDanger or other.isPickup ) then\n\t\t-- skip\n\telseif( contact and contact.isEnabled ) then\n\t\tif( (self.y - other.y) > -(self.contentHeight/2 + other.contentHeight/2 - 1) ) then\n\t\t\tcontact.isEnabled = false\n\t\tend\n\tend\t\n\treturn false\nend; player:addEventListener(\"preCollision\")\n\nfunction player.collision( self, event )\n\tlocal other = event.other\n\tif( event.phase == \"began\" ) then\n\t\tlocal vx, vy = self:getLinearVelocity()\n\t\tif( other.isDanger ) then\n\t\t\tgameover()\n\t\t\n\t\telseif( other.isPickup ) then\n\t\t\tpickupCount = pickupCount + 100\n\t\t\tscoreLabel:update()\n\t\t\tdisplay.remove(other)\n\t\t\n\t\telseif( other.isSpring and not other.open and vy > 0 ) then\n\t\t\tself:setLinearVelocity( vx, -jumpSpeed * 1.25 )\n\t\t\tother.open = true\n\t\t\ttimer.performWithDelay( 50,  function() other:setFillColor( 0.5, 0.7 ) end )\n\t\t\n\t\telseif( other.isPlatform and vy > 0 ) then\n\t\t\tself:setLinearVelocity( vx, -jumpSpeed  )\n\t\tend\n\tend\n\treturn false\nend; player:addEventListener(\"collision\")\n\nlocal lastY\nlocal lastX\nlocal function createGameObject( x, y, objectType )\n\tx = x or lastX\n\ty = y or lastY\n\tif( not gameIsRunning ) then return nil end\n\tlocal obj\n\tif( objectType == \"platform\" ) then\n\t\tobj = newImageRect( layers.background, \"img/platformBase\"..math.random(2) ..\".png\", 192, 72 )\n\t\tobj.x = x\n\t\tobj.isPlatform = true\n\t\tobj.anchorY = 0\n\t\tphysics.addBody( obj, \"static\", { bounce = 0 } )\n\t\tlastX = x\n\t\tlastY = y\n\n\telseif( objectType == \"spring\" ) then\n\t\tobj = newImageRect( layers.background, \"img/spaceSprint.png\", 58, 58 )\n\t\tobj.rotation = -90\n\t\tobj.x = x + mRand(-40, 40)\n\t\tobj.isSpring = true\n\t\tobj.anchorY = 1\n\t\tphysics.addBody( obj, \"static\", { bounce = 0, radius = 29 } )\n\t\n\telseif( objectType == \"pickup\" ) then\n\t\tobj = newImageRect( layers.background, \"img/gemRedStroked.png\", 48, 48 )\n\t\tobj.x = x + mRand(-40, 40)\n\t\tobj.isPickup = true\n\t\tobj.anchorY = 1\n\t\tphysics.addBody( obj, \"static\", { bounce = 0 } )\n\t\tobj.isSensor = true\n\t\n\telseif( objectType == \"danger\" ) then\n\t\tobj = newImageRect( layers.background, \"img/blobGreen.png\", 72, 48 )\n\t\tobj.x = x + mRand(-40, 40)\n\t\tobj.isDanger = true\n\t\tobj.anchorY = 1\n\t\tphysics.addBody( obj, \"static\", { bounce = 0 } )\n\t\tobj.isSensor = true\n\t\t\n\tend\n\tobj.y = y\nend\n\nlocal function levelGen( noItems )\n\twhile lastY > (player.y - display.actualContentHeight * 0.75) do\n\t\tif not gameIsRunning then break end\n\t\tcreateGameObject( centerX + mRand( -400, 400 ) , lastY - mRand( 100, 200 ), \"platform\" )\n\t\t-- Generate other item too?\n\t\tif( not noItems and mRand( 1, 100 ) > 20 ) then\n\t\t\tlocal items = { \"danger\", \"pickup\", \"pickup\", \"spring\", \"spring\", \"spring\"  }\n\t\t\tcreateGameObject( nil, nil, items[mRand(1,#items)] )\n\t\tend\n\tend\nend\n\nfunction player.enterFrame( self )\n\tcamera.y = player.y + offsetCamera\n\t\n\tif( camera.y < camera.lastY ) then\n\t\tlayers.world.y = layers.world.y + (camera.lastY - camera.y)\n\t\tcamera.lastY = camera.y\n\t\tlevelGen()\n\tend\n\t\n\tif player.contentBounds.yMax >= display.actualContentHeight then\n\t\tgameover()\n\tend\n\n\tlocal dist = math.round(self.startY - self.y)\n\tif( dist > distance ) then \n\t\tdistance = dist \n\t\tscoreLabel:update()\n\tend\n\t\n\tif(self.x >= rightEdge) then\n\t\tself.x = leftEdge + self.x - rightEdge\n\telseif(self.x <= leftEdge) then\n\t\tself.x = rightEdge + self.x - leftEdge\n\tend\n\n\tlocal vx, vy = self:getLinearVelocity()\n\tvx = 0\n\tvx = vx - self.moveLeft * horizSpeed\n\tvx = vx + self.moveRight * horizSpeed\n\tself:setLinearVelocity( vx, vy )\nend; listen( \"enterFrame\", player )\n\ncreateGameObject( player.x, player.y + 100, \"platform\" )\nlevelGen(true)\n\n-- Create mouse and keyboard listeners to control the character, and prevent the\n-- player from using one control method if they are currently using the other one.\nlocal holdingKey, holdingMouse\nRuntime:addEventListener( \"key\", function(event)\n\tif not holdingMouse then\n\t\tlocal key = event.keyName\n\t\tif event.phase == \"down\" then\n\t\t\tif key == \"a\" or key == \"left\" then\n\t\t\t\tplayer.moveLeft, player.moveRight = 1, 0\n\t\t\t\tholdingKey = key\n\t\t\telseif key == \"d\" or key == \"right\" then\n\t\t\t\tplayer.moveLeft, player.moveRight = 0, 1\n\t\t\t\tholdingKey = key\n\t\t\tend\n\t\telse\n\t\t\tif holdingKey and holdingKey == key then\n\t\t\t\tplayer.moveLeft, player.moveRight = 0, 0\n\t\t\t\tholdingKey = nil\n\t\t\tend\n\t\tend\n\tend\nend )\n\nRuntime:addEventListener( \"touch\", function(event)\n\tif gameIsRunning and not holdingKey then\n\t\tif event.phase == \"began\" or event.phase == \"moved\" then\n\t\t\tholdingMouse = true\n\t\t\tif event.x >= centerX then\n\t\t\t\tplayer.moveLeft, player.moveRight = 0, 1\n\t\t\telse\n\t\t\t\tplayer.moveLeft, player.moveRight = 1, 0\n\t\t\tend\n\t\telse\n\t\t\tplayer.moveLeft, player.moveRight = 0, 0\n\t\t\tholdingMouse = false\n\t\tend\n\tend\nend )\n"
    },
    
    {
        "title": "Match-3",
        "code": "-- Sample code by Kan.\n\nlocal rnd = math.random\nlocal abs = math.abs\n\nlocal board = display.newGroup() -- Group of board game\nboard.anchorChildren = true\nboard.x, board.y = 320, 130 -- Center screen\n\nlocal directions = {\n\t{row = -1, col = 0}, -- up\n\t{row = 1, col = 0}, -- down\n\t{row = 0, col = 1}, -- right\n\t{row = 0, col = -1}, --left\n}\n\nlocal colors = {\n\t{.5, .7, .3},\n\t{1, .5, 0},\n\t{.8, .8, 0},\n\t{0, .8, 0},\n\t{.2, .6, .5}\n}\n\nlocal pieces = {}\n\nlocal margin = 5\n\nlocal cols = 8\nlocal rows = 8\nlocal radius = 25\nlocal x = 0\nlocal y = 0\n\n-- Create board\nfor r = 1, rows do\n\tfor c = 1, cols do\n\t\tlocal _index = #pieces + 1 -- New piece\n\t\tpieces[_index] = display.newCircle(board, x, y, radius)\n\t\tlocal piece = pieces[_index]\n\t\tx = x + piece.contentWidth + margin\n\t\tpiece.col = c\n\t\tpiece.row = r\n\t\tpiece.value = rnd(1, #colors) -- Random color\n\t\tpiece:setFillColor(unpack(colors[piece.value]))\n\n\t\tfunction piece:touch( event )\n\t\t\tif event.phase == \"began\" then\n\t\t\t\tlocal oldTarget\n\t\t\t\t\n\t\t\t\tfor i = 1, #pieces do\n\t\t\t\t\tif pieces[i].isTarget then\n\t\t\t\t\t\toldTarget = pieces[i]\n\t\t\t\t\tend\n\t\t\t\tend\n\n\t\t\t\tif oldTarget then\n\t\t\t\t\tlocal isNeighbor = isNeighbor(oldTarget, self)\n\t\t\t\t\tif isNeighbor then\n\t\t\t\t\t\ttransition.cancel(oldTarget)\n\t\t\t\t\t\toldTarget.alpha = 1\n\t\t\t\t\t\toldTarget.xScale = 1\n\t\t\t\t\t\toldTarget.yScale = 1\n\t\t\t\t\t\toldTarget.isTarget = false\n\n\t\t\t\t\t\t-- swap\n\t\t\t\t\t\toldTarget.col, self.col = self.col, oldTarget.col\n\t\t\t\t\t\toldTarget.row, self.row = self.row, oldTarget.row\n\n\t\t\t\t\t\ttransition.to(oldTarget, {time = 100, x = self.x, y = self.y, onComplete = function()\n\t\t\t\t\t\t\t\n\t\t\t\t\t\tend})\n\n\t\t\t\t\t\ttransition.to(self, {time = 100, x = oldTarget.x, y = oldTarget.y, onComplete = function()\n\t\t\t\t\t\t\tlocal isMatch = false\n\t\t\t\t\t   \n\t\t\t\t\t\t\tfor i = 1, #pieces do\n\t\t\t\t\t\t\t\tif matched(pieces[i]) then\n\t\t\t\t\t\t\t\t\tisMatch = true\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tif not isMatch then\n\t\t\t\t\t\t\t\t-- swap\n\t\t\t\t\t\t\t\toldTarget.col, self.col = self.col, oldTarget.col\n\t\t\t\t\t\t\t\toldTarget.row, self.row = self.row, oldTarget.row\n\t\t\t\t\t\t\t\ttransition.to(oldTarget, {delay = 100, time = 100, x = self.x, y = self.y, onComplete = function()\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tend})\n\t\t\t\t\t\t\t\ttransition.to(self, {delay = 100, time = 100, x = oldTarget.x, y = oldTarget.y, onComplete = function()\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tend})\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tcleanMatched()\n\t\t\t\t\t\t\tend\n\n\t\t\t\t\t\tend})\n\t\t\t\t\telse\n\t\t\t\t\t\ttransition.cancel(oldTarget)\n\t\t\t\t\t\toldTarget.alpha = 1\n\t\t\t\t\t\toldTarget.xScale = 1\n\t\t\t\t\t\toldTarget.yScale = 1\n\t\t\t\t\t\toldTarget.isTarget = false\n\n\t\t\t\t\t\tself.xScale = 1.1\n\t\t\t\t\t\tself.yScale = 1.1\n\t\t\t\t\t\ttransition.blink(self, {time = 1000})\n\t\t\t\t\t\tself.isTarget = true\n\t\t\t\t\tend\n\t\t\t\telse\n\t\t\t\t\tself.xScale = 1.1\n\t\t\t\t\tself.yScale = 1.1\n\t\t\t\t\ttransition.blink(self, {time = 1000})\n\t\t\t\t\tself.isTarget = true\n\n\t\t\t\tend\n\t\t\tend\n\t\t\treturn true\n\t\tend\n\t\tpiece:addEventListener(\"touch\")\n\tend\n\tx = 0 -- move to left\n\ty = y + radius*2 + margin\nend\n\nfunction isNeighbor(cur, next)\n\tlocal offsetCol = abs(cur.col - next.col)\n\tlocal offsetRow = abs(cur.row - next.row)\n\n\tif (offsetCol == 1 and offsetRow == 0) or (offsetCol == 0 and offsetRow == 1) then\n\t\treturn true\n\tend\n\n\treturn false\nend\n\nfunction matched(item)\n\tlocal isMatched = false\n\t\n\t--- Check for direction\n\tfor i = 1, #directions do\n\t\tlocal dir = directions[i]\n\t\tlocal matched = 0\n\n\t\tlocal tempList = {}\n\t\tlocal currentPiece = item\n\t\ttempList[1] = currentPiece\n\n\t\twhile true do\n\t\t\tlocal row = currentPiece.row + dir.row\n\t\t\tlocal col = currentPiece.col + dir.col\n\n\t\t\tif row >= rows+1 or row <= 0 or col >= cols+1 or col <= 0 then\n\t\t\t\tbreak\n\t\t\tend\n\t\t\t\n\t\t\tlocal nextPiece = findPiece(col, row)\n\n\t\t\tif not nextPiece then print(\"not find position\", row, col) break end\n\t\t\tif currentPiece.value == nextPiece.value then\t  \n\t\t\t\tmatched = matched + 1\n\t\t\t\ttempList[#tempList+1] = nextPiece\n\t\t\t\tcurrentPiece = nextPiece\n\t\t\telse\n\t\t\t\ttempList = nil\n\t\t\t\tcurrentPiece = nil\n\t\t\t\tbreak\n\t\t\tend\n\n\t\t\tif matched > 1 then\n\t\t\t\tisMatched = true\n\t\t\t\tfor i = 1, #tempList do\n\t\t\t\t\ttempList[i].isMatched = true\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn isMatched\nend\n\nfunction cleanMatched()\n\tfor i = 1, #pieces do\n\t\tlocal piece = pieces[i]\n\t\tif piece.isMatched then\n\t\t\tpiece.isMatched = false\n\t\t\tpiece.isRepulish = true\n\t\t\ttransition.to(piece, {time = 50, xScale = 0.01, yScale = 0.01, onComplete = function()\n\t\t\t\tpiece.value = rnd(1,#colors)\n\t\t\t\tpiece:setFillColor(unpack(colors[piece.value]))\n\t\t\tend})\n\t\tend\n\tend\n\n\tfor i = 1, #pieces do\n\t\tlocal piece = pieces[i]\n\t\tif piece.isRepulish then\n\t\t\tpiece.isRepulish = false\n\t\t\ttransition.to(piece, {delay = 200, time = 300, xScale = 1, yScale = 1, onComplete = function()\n\t\t\tend})\n\t\tend\n\tend\n\n\ttimer.performWithDelay(501, function()\n\t\tlocal isMatched\n\t\tfor i = 1, #pieces do\n\t\t\tif matched(pieces[i]) then\n\t\t\t\tisMatched = true\n\t\t\tend\n\t\tend\n\t\tif isMatched then\n\t\t\tcleanMatched()\n\t\tend\n\tend, 1)\nend\n\nfunction findPiece(col, row)\n\tif pieces == nil then return false end\n\n\tfor i = 1, #pieces do\n\t\tlocal piece = pieces[i]\n\t\tif piece.col == col and piece.row == row then\n\t\t\treturn piece\n\t\tend\n\tend\n\n\treturn false\nend\n\nfunction verify(p)\n\tlocal isMatched = false\n\n\t--- Check for direction\n\tfor i = 1, #directions do\n\t\tlocal dir = directions[i]\n\t\tlocal matched = 0\n\n\t\tlocal currentPiece = p\n\n\t\twhile true do\n\n\t\t\tlocal row = currentPiece.row + dir.row\n\t\t\tlocal col = currentPiece.col + dir.col\n\n\t\t\tif row >= rows+1 or row <= 0 or col >= cols+1 or col <= 0 then\n\t\t\t\tbreak\n\t\t\tend\n\t\t\t\n\t\t\tlocal nextPiece = findPiece(col, row)\n\n\t\t\tif not nextPiece then print(\"not find position\", row, col) break end\n\t\t\tif currentPiece.value == nextPiece.value then\t   \n\t\t\t\tmatched = matched + 1\n\t\t\t\tcurrentPiece = nextPiece\n\t\t\telse\n\t\t\t\tbreak\n\t\t\tend\n\n\t\t\tif matched > 1 then\n\t\t\t\tisMatched = true\n\t\t\t\treturn isMatched\n\t\t\tend\n\t\tend\n\tend\n\n\t-- Check in middle\n\tfor i = 1, 2 do\n\t\tlocal dirs = {directions[i], directions[i+2]}\n\t\tlocal matched = 0\n\n\t\tlocal currentPiece = p\n\n\t\tlocal row1 = currentPiece.row + dirs[1].row\n\t\tlocal col1 = currentPiece.col + dirs[1].col\n\n\t\tlocal row2 = currentPiece.row + dirs[2].row\n\t\tlocal col2 = currentPiece.col + dirs[2].col\n\n\t\tif row1 >= rows+1 or row1 <= 0 or col1 >= cols+1 or col1 <= 0 then\n\t\t\tbreak\n\t\tend\n\n\t\tif row2 >= rows+1 or row2 <= 0 or col2 >= cols+1 or col2 <= 0 then\n\t\t\tbreak\n\t\tend\n\n\t\tlocal twoSidesPieces = {\n\t\t\tfindPiece(col1, row1),\n\t\t\tfindPiece(col2, row2)\n\t\t}\n\n\t\tfor i, _piece in ipairs(twoSidesPieces) do\n\t  \n\t\t\tif not _piece then print(\"not find position\") break end\n\t\t\tif currentPiece.value == _piece.value then\n\t\t\t\tmatched = matched + 1\n\t\t\tend \n\t\tend\n\n\t\tif matched > 1 then\n\t\t\tisMatched = true\n\t\t\treturn isMatched\n\t\tend\n\tend\n\n\t-- Check for 2x2\n\tfor i = 1, 4 do\n\t\tlocal matched = 0\n\t\tlocal next = i + 1\n\t\tif next >= 5 then\n\t\t\tnext = next - 4\n\t\tend\n\t\tlocal r1 = p.row + directions[i].row\n\t\tlocal c1 = p.col + directions[i].col\n\t\tlocal r2 = p.row + directions[next].row\n\t\tlocal c2 = p.col + directions[next].col\n\t\tlocal r3 = p.row + (directions[i].row + directions[next].row)\n\t\tlocal c3 = p.col + (directions[i].col + directions[next].col)\n\n\t\tif r1 >= rows+1 or r1 <= 0 or c1 >= cols+1 or c1 <= 0 then\n\t\t\tbreak\n\t\tend\n\n\t\tif r2 >= rows+1 or r2 <= 0 or c2 >= cols+1 or c2 <= 0 then\n\t\t\tbreak\n\t\tend\n\n\t\tif r3 >= rows+1 or r3 <= 0 or c3 >= cols+1 or c3 <= 0 then\n\t\t\tbreak\n\t\tend\n\t\tlocal neighborsPieces = {\n\t\t\tfindPiece(c1, r1),\n\t\t\tfindPiece(c2, r2),\n\t\t\tfindPiece(c3, r3)\n\t\t}\n\n\t\tfor i, _piece in ipairs(neighborsPieces) do\n\t\t\tif not _piece then print(\"not find position\") break end\n\t\t\tif p.value == _piece.value then\n\t\t\t\tmatched = matched + 1\n\t\t\tend \n\t\tend\n\n\t\tif matched > 2 then\n\t\t\tisMatched = true\n\t\t\treturn isMatched\n\t\tend\n\tend\nend\n\n-- Clean match piece\nlocal idx = 0\n\nwhile idx < #pieces do\n\tidx = idx + 1\n\n\tif not pieces[idx] then print(\"Item is not exist.\") break end\n\t\n\tlocal isMatched = verify(pieces[idx])\n\tif isMatched then\n\t\twhile true do\n\t\t\tlocal newValue = math.random(1, #colors)\n\t\t\tif pieces[idx].value ~= newValue then\n\t\t\t\tpieces[idx]:setFillColor(unpack(colors[newValue]))\n\t\t\t\tpieces[idx].value = newValue\n\t\t\t\tidx = 0\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\tend\nend"
    },
    
    {
        "title": "Shader Fun",
        "code": "-- Original shader by Michael Wilson.\n-- [Code adapted for Playground by Eetu Rantanen]\n\n-- WARNING --\n-- This sample project is currently only intended to be used in beta mode.\n-- Running this project on the main-Playground will result in a runtime error.\n-- WARNING --\n\n-- Create a custom shader.\nlocal kernel = {}\nkernel.language = \"glsl\"\nkernel.category = \"filter\"\nkernel.name = \"multiswap\"\n\n-- Expose effect parameters using vertex data.\nkernel.uniformData = {\n\t{\n\t\tname = \"keys\",\n\t\tdefault = {\n\t\t\t1.0, 1.0, 1.0, 1.0,\n\t\t\t1.0, 1.0, 1.0, 1.0,\n\t\t\t1.0, 1.0, 1.0, 1.0,\n\t\t\t1.0, 1.0, 1.0, 1.0\n\t\t},\n\t\tmin = {\n\t\t\t0.0, 0.0, 0.0, 0.0,\n\t\t\t0.0, 0.0, 0.0, 0.0,\n\t\t\t0.0, 0.0, 0.0, 0.0,\n\t\t\t0.0, 0.0, 0.0, 0.0\n\t\t},\n\t\tmax = {\n\t\t\t1.0, 1.0, 1.0, 1.0,\n\t\t\t1.0, 1.0, 1.0, 1.0,\n\t\t\t1.0, 1.0, 1.0, 1.0,\n\t\t\t1.0, 1.0, 1.0, 1.0\n\t\t},\n\t\ttype=\"mat4\",\n\t\tindex = 0, -- u_UserData0\n\t},\n\t{\n\t\tname = \"colors\",\n\t\tdefault = {\n\t\t\t1.0, 1.0, 1.0, 1.0,\n\t\t\t1.0, 1.0, 1.0, 1.0,\n\t\t\t1.0, 1.0, 1.0, 1.0,\n\t\t\t1.0, 1.0, 1.0, 1.0\n\t\t},\n\t\tmin = {\n\t\t\t0.0, 0.0, 0.0, 0.0,\n\t\t\t0.0, 0.0, 0.0, 0.0,\n\t\t\t0.0, 0.0, 0.0, 0.0,\n\t\t\t0.0, 0.0, 0.0, 0.0\n\t\t},\n\t\tmax = {\n\t\t\t1.0, 1.0, 1.0, 1.0,\n\t\t\t1.0, 1.0, 1.0, 1.0,\n\t\t\t1.0, 1.0, 1.0, 1.0,\n\t\t\t1.0, 1.0, 1.0, 1.0\n\t\t},\n\t\ttype=\"mat4\",\n\t\tindex = 1, -- u_UserData1\n\t},\n}\n\nkernel.fragment = [[\nuniform P_COLOR mat4 u_UserData0; // keys\nuniform P_COLOR mat4 u_UserData1; // colors\nP_COLOR vec4 FragmentKernel( P_UV vec2 texCoord )\n{\n\tP_COLOR vec4 texColor = texture2D( CoronaSampler0, texCoord );\n\tfor(int i = 0; i < 4; i++)\n\t{\n\t\tP_COLOR vec4 keys = u_UserData0[i];\n\t\tP_COLOR vec4 colors = u_UserData1[i];\n\t\tif ((abs(texColor[0] - keys[0]) < 0.2) && (abs(texColor[1] - keys[1]) < 0.2) && (abs(texColor[2] - keys[2]) < 0.2))\n\t\t{\n\t\t\ttexColor = colors;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn CoronaColorScale(texColor);\n}\n]]\ngraphics.defineEffect( kernel )\n\n-- Create a character to apply the shader to.\nlocal character = display.newImage( \"img/skeleton.png\", 480, 320 )\ncharacter:scale(3,3)\n\nlocal random = math.random\nlocal timerShader\n\nlocal function toggleShader( event )\n\tif event.phase == \"began\" then\n\t\tif timerShader then\n\t\t\t-- Remove the effect and stop the timer.\n\t\t\tcharacter.fill.effect = nil\n\t\t\ttimer.cancel( timerShader )\n\t\t\ttimerShader = nil\n\t\telse\n\t\t\t-- Apply the shader and define the colours to swap.\n\t\t\tcharacter.fill.effect = \"filter.custom.multiswap\"\n\t\t\tcharacter.fill.effect.keys = {\n\t\t\t\t255/255,  255/255,  255/255, 1,\n\t\t\t\t53/255,  151/255, 211/255, 1,\n\t\t\t\t150/255, 91/255, 165/255, 1,\n\t\t\t\t240/255, 196/255, 23/255, 1\n\t\t\t}\n\t\t\t-- Keep swapping to random colours indefinitely.\n\t\t\ttimerShader = timer.performWithDelay( 100, function()\n\t\t\t\tcharacter.fill.effect.colors = {\n\t\t\t\t\trandom(), random(),  random(), 1,\n\t\t\t\t\trandom(), random(),  random(), 1,\n\t\t\t\t\trandom(), random(),  random(), 1,\n\t\t\t\t\trandom(), random(),  random(), 1,\n\t\t\t\t}\n\t\t\tend, 0 )\n\t\tend\n\tend\nend\n\n-- Add touch controls for the shader effect and start it.\nRuntime:addEventListener( \"touch\", toggleShader )\ntoggleShader( {phase=\"began\"} )"
    }
]